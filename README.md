# Telegram NFT Gift Scraper

Этот Python-скрипт предназначен для парсинга информации о NFT-подарках с сайта Telegram (`t.me/nft/COLLECTION_SLUG-ID`). Он извлекает метаданные о каждом NFT, а также может скачивать связанные с ним .TGS файлы (анимированные стикеры) и .PNG файлы (паттерны фона).

## Оглавление

1.  [Возможности](#возможности)
2.  [Требования](#требования)
3.  [Установка](#установка)
4.  [Использование](#использование)
    - [Основные аргументы](#основные-аргументы)
    - [Управление скачиванием](#управление-скачиванием)
    - [Производительность и сеть](#производительность-и-сеть)
    - [Продвинутые опции](#продвинутые-опции)
5.  [Структура выходных данных](#структура-выходных-данных)
    - [JSON файл](#json-файл)
    - [Скачанные файлы](#скачанные-файлы)
6.  [Примеры использования](#примеры-использования)
7.  [Важные замечания](#важные-замечания)
8.  [Поиск и устранение неисправностей](#поиск-и-устранение-неисправностей)

## Возможности

- **Извлечение метаданных**: Собирает информацию о NFT, такую как:
  - `collectible_id`: ID коллекционного предмета.
  - `nft_name`: Название NFT.
  - `owner`: Владелец (если указан).
  - `model`: Модель (часто используется для именования .TGS файла).
  - `backdrop`: Фон (описание).
  - `symbol`: Символ (часто используется для именования файла паттерна).
  - `quantity`: Общее количество и/или количество выпущенных.
  - `gradient_from`, `gradient_to`: Цвета градиента фона.
  - `pattern_png_url`: URL PNG-изображения паттерна.
  - `pattern_tint`: Оттенок, применяемый к паттерну.
  - `image_svg_b64`: Base64-кодированное SVG-изображение превью.
  - `tgs_url`: URL .TGS файла анимированного стикера.
  - `page_scraped_url`: URL страницы, с которой были взяты данные.
- **Скачивание файлов**:
  - Загружает .TGS файлы моделей.
  - Загружает .PNG файлы паттернов.
- **Асинхронность**: Использует `asyncio` и `aiohttp` для быстрого параллельного сбора данных с нескольких страниц.
- **Кэширование скачанных файлов**: Файлы с одинаковыми URL скачиваются только один раз, даже если они встречаются в разных NFT или коллекциях (в рамках одного запуска скрипта).
- **Гибкая настройка**: Позволяет указать диапазон ID, задержку между запросами, количество одновременных запросов.
- **Автоматическое определение последнего ID**: Может автоматически определять общее количество NFT в коллекции.
- **Режим "только JSON"**: Возможность собирать только метаданные без скачивания файлов.
- **Поддержка прокси**: Возможность использовать HTTP/HTTPS прокси для запросов.
- **Обработка нескольких коллекций**: Можно указать одну или несколько коллекций для парсинга за один запуск.
- **Обновление данных**: При повторном запуске для той же коллекции и того же выходного файла, скрипт загружает существующие данные и обновляет их или добавляет новые.

## Требования

- Python 3.7+
- pip (менеджер пакетов Python)
- Зависимости Python (будут установлены автоматически):
  - `requests`
  - `aiohttp`
  - `beautifulsoup4`
  - `tqdm`

## Установка

1.  **Клонируйте репозиторий или скачайте скрипт:**
    Если это часть репозитория:

    ```bash
    git clone <URL_РЕПОЗИТОРИЯ>
    cd <ПАПКА_РЕПОЗИТОРИЯ>
    ```

    Или просто скачайте файл `gift-parser-hard.py` в нужную директорию.

2.  **Создайте и активируйте виртуальное окружение (рекомендуется):**

    ```bash
    python -m venv venv
    # Windows
    venv\Scripts\activate
    # macOS/Linux
    source venv/bin/activate
    ```

3.  **Установите зависимости:**
    Создайте файл `requirements.txt` в той же директории, что и скрипт, со следующим содержимым:
    ```txt
    requests
    aiohttp
    beautifulsoup4
    tqdm
    ```
    Затем выполните:
    ```bash
    pip install -r requirements.txt
    ```

## Использование

Скрипт запускается из командной строки командой `python gift-parser-hard.py [АРГУМЕНТЫ]`.

### Основные аргументы

- `--slug SLUG`:
  Slug (короткое имя) **одной** коллекции NFT для парсинга. Например, `AstralShard`.

- `--slugs SLUG1 SLUG2 ...`:
  Список слагов **нескольких** коллекций NFT, разделенных пробелами. Например, `AstralShard SomeOtherCollection YetAnother`.
  _Примечание: `--slug` и `--slugs` взаимоисключающие. Используйте только один из них._

- `--first ID` (опционально, по умолчанию: `1`):
  Начальный ID NFT в коллекции для парсинга.

- `--last ID` (опционально, по умолчанию: `10`):
  Конечный ID NFT в коллекции для парсинга (включительно). Игнорируется, если используется `--auto-last` и определение проходит успешно.

- `--output FILENAME.json` (опционально, по умолчанию: `nft_collection_data.json`):
  Имя выходного JSON файла.
  - При использовании `--slug`, это имя будет использовано для указанной коллекции.
  - При использовании `--slugs`, это значение игнорируется, и для каждой коллекции будет сгенерирован свой файл вида `<SLUG>_collection_data.json`.

### Управление скачиванием

- `--json-only` (опционально):
  Если указан, скрипт будет только собирать метаданные в JSON и **не будет** скачивать .TGS и .PNG файлы. Поля `tgs_file_path` и `pattern_file_path` в JSON будут содержать исходные URL (если доступны).

### Производительность и сеть

- `--delay SECONDS` (опционально, по умолчанию: `0.1`):
  Задержка в секундах между запросами, выполняемыми **каждым** воркером. Установите `0` для отключения задержки (не рекомендуется для больших объемов).

- `--workers COUNT` (опционально, по умолчанию: `10`):
  Количество одновременных асинхронных воркеров (запросов) для сбора HTML-страниц.

- `--proxy URL` (опционально, по умолчанию: `None`):
  URL прокси-сервера в формате `http://user:pass@host:port` или `http://host:port`. Используется для всех HTTP-запросов (получение HTML и скачивание файлов).

### Продвинутые опции

- `--auto-last` (опционально):
  Если указан, скрипт попытается автоматически определить максимальный ID (общее количество) NFT в коллекции, запрашивая страницу первого NFT (или указанного через `--start-nft-id-for-total`). Если успешно, значение `--last` будет проигнорировано.

- `--start-nft-id-for-total ID` (опционально, по умолчанию: `1`):
  ID NFT, который будет использоваться для определения общего количества при активном флаге `--auto-last`. Обычно `1` подходит, но для некоторых коллекций нумерация может начинаться с другого числа, или первый NFT может быть удален.

## Структура выходных данных

Скрипт создает JSON файл с метаданными и, если не включен режим `--json-only`, папки для скачанных файлов. Все пути создаются относительно директории, из которой запущен скрипт.

### JSON файл

- Для каждой коллекции создается (или обновляется) JSON файл.
- Файл содержит список объектов, где каждый объект представляет один NFT.
- Пример структуры объекта NFT:

  ```json
  [
    {
      "collectible_id": 1,
      "nft_name": "Astral Shard",
      "owner": "@username или адрес кошелька",
      "model": "Animated Shard 75%",
      "backdrop": "Cosmic Swirl",
      "symbol": "AST75",
      "quantity": "1 / 1,000 issued",
      "gradient_from": "#RRGGBB",
      "gradient_to": "#RRGGBB",
      "pattern_png_url": "https://cdn4.cdn-telegram.org/file/...",
      "pattern_tint": "#RRGGBB",
      "image_svg_b64": "BASE64_ENCODED_SVG_STRING",
      "tgs_url": "https://cdn4.cdn-telegram.org/file/...",
      "tgs_file_path": "AstralShard_tgs/Animated_Shard_75.tgs",
      "pattern_file_path": "AstralShard_patterns/AST75.png",
      "page_scraped_url": "https://t.me/nft/AstralShard-1"
    }
    // ... другие NFT
  ]
  ```

- Если включен режим `--json-only`, поля `tgs_file_path` и `pattern_file_path` будут содержать исходные URL вместо локальных путей.
- Если файл уже существует, скрипт загрузит из него данные, относящиеся к текущей обрабатываемой коллекции, и обновит/добавит новые записи.

### Скачанные файлы

Если режим `--json-only` не активен:

1.  **Папка для .TGS файлов**:

    - Создается папка с именем `<COLLECTION_SLUG>_tgs` (например, `AstralShard_tgs`).
    - В нее скачиваются .TGS файлы. Имя файла формируется из поля `model` (очищенного от спецсимволов и процентов), либо используется MD5-хеш от URL, если имя модели не удалось определить.
    - Путь к скачанному файлу (относительно папки скрипта) записывается в `tgs_file_path` в JSON.

2.  **Папка для .PNG паттернов**:
    - Создается папка с именем `<COLLECTION_SLUG>_patterns` (например, `AstralShard_patterns`).
    - В нее скачиваются .PNG файлы паттернов. Имя файла формируется из поля `symbol` (очищенного), либо используется MD5-хеш от URL, если символ не удалось определить или он пуст.
    - Путь к скачанному файлу (относительно папки скрипта) записывается в `pattern_file_path` в JSON.

## Примеры использования

1.  **Спарсить первые 50 NFT из коллекции "PlushPepe" и скачать файлы:**

    ```bash
    python gift-parser-hard.py --slug Plushpepe --first 1 --last 50 --output plush_pepe_data.json
    ```

    - Результат: `plush_pepe_data.json`, папки `Plushpepe_tgs/` и `Plushpepe_patterns/`.

2.  **Спарсить все NFT из коллекции "PlushPepe", автоматически определив последний ID, только JSON:**

    ```bash
    python gift-parser-hard.py --slug Plushpepe --auto-last --json-only --output cryptogems.json
    ```

    - Результат: `plushpepe.json`. Файлы не скачиваются.

3.  **Спарсить коллекции "PlushPepe" (ID 1-100) и "SignetRing" (ID 1-50) с использованием прокси и увеличенным числом воркеров:**

    ```bash
    python gift-parser-hard.py --slugs Plushpepe signetring --first 1 --last 100 --workers 20 --proxy http://user:pass@proxyserver:8080
    ```

    - Примечание: `--last 100` применится к обеим коллекциям. Если для "SignetRing" нужно другое значение `last`, или если вы хотите использовать `--auto-last`, запускайте команды отдельно для каждой коллекции или модифицируйте скрипт для более гранулярного контроля `--last` при использовании `--slugs`.
    - Результат: `Plushpepe_collection_data.json`, `Signetring_collection_data.json`, и соответствующие папки с файлами.

4.  **Спарсить коллекцию "TestCollection", где нумерация NFT для определения общего количества должна проверяться с NFT ID 5:**

    ```bash
    python gift-parser-hard.py --slug TestCollection --auto-last --start-nft-id-for-total 5
    ```

## Важные замечания

- **Уважение к серверам**: Не устанавливайте слишком большое количество воркеров (`--workers`) и слишком маленькую задержку (`--delay 0`), особенно для больших коллекций. Это может создать чрезмерную нагрузку на серверы Telegram и привести к временной блокировке вашего IP-адреса.
- **Прокси**: Для парсинга больших объемов данных настоятельно рекомендуется использовать прокси (`--proxy`) во избежание блокировок.
- **Пути к файлам**: Все пути к выходным файлам и папкам генерируются относительно директории, из которой запущен скрипт.
- **Обработка ошибок**: Скрипт пытается обработать основные ошибки (сетевые, 404). Если страница не найдена или не может быть обработана, она пропускается. При ошибках парсинга HTML-содержимое проблемной страницы сохраняется в файл `error_page_<SLUG>_<ID>.html` для последующего анализа.
- **Имена файлов**: Имена скачиваемых .TGS и .PNG файлов формируются на основе полей "model" и "symbol" из метаданных NFT. Если эти поля отсутствуют или пусты, используется MD5-хеш от URL файла, чтобы обеспечить уникальность. Специальные символы и пробелы в именах заменяются.

## Поиск и устранение неисправностей

- **Скрипт не находит NFT / Ошибки 404**:
  - Проверьте правильность написания `slug` коллекции.
  - Убедитесь, что указанный диапазон `first`-`last` ID существует для данной коллекции.
  - Возможно, ваш IP временно заблокирован. Попробуйте использовать `--proxy` или подождать некоторое время.
- **Медленная работа**:
  - Увеличьте `--workers` (с осторожностью).
  - Уменьшите `--delay` (с осторожностью).
  - Проверьте скорость вашего интернет-соединения и прокси (если используется).
- **Ошибки парсинга**:
  - Если видите сообщения об ошибках парсинга, проверьте сохраненные файлы `error_page_*.html`. Возможно, структура страницы изменилась.
- **Длинные имена файлов (Windows)**:
  - В редких случаях, если `model` или `symbol` содержат очень длинные строки, итоговое имя файла может превысить лимит операционной системы Windows. Скрипт пытается это обработать, но если проблема возникает, это может указывать на аномальные данные на странице.
